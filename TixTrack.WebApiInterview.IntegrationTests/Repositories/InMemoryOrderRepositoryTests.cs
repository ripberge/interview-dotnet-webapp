using TixTrack.WebApiInterview.Entities;
using TixTrack.WebApiInterview.Repositories;
using TixTrack.WebApiInterview.Repositories.Context;
using Xunit;

namespace TixTrack.WebApiInterview.IntegrationTests.Repositories;

public partial class InMemoryOrderRepositoryTests
{
    [Fact]
    public async Task ActiveOrdersDoNotContainCancelledOrders()
    {
        var expectedOrders = new List<Order> { _activeOrder, _cancelledOrder };
        await Task.WhenAll(expectedOrders.Select(_orderRepository.Create));

        var actualActiveOrders = await _orderRepository.FindActive();

        Assert.Single(actualActiveOrders);
        Assert.Equal(expectedOrders.First(), actualActiveOrders.Single());
    }

    [Fact]
    public async Task AllOrdersContainActiveAndCancelledOrders()
    {
        var expectedOrders = new List<Order> { _activeOrder, _cancelledOrder };
        await Task.WhenAll(expectedOrders.Select(_orderRepository.Create));
        
        var actualOrders = await _orderRepository.FindAll();

        Assert.All(expectedOrders,
            expectedOrder => Assert.Contains(expectedOrder, actualOrders));
    }
    
    [Fact]
    public async Task OrderIdIsAutogeneratedByRepository()
    {
        var firstAutogeneratedId =
            (await _orderRepository.Create(_activeOrder with { Id = null })).Id;
        var secondAutogeneratedId =
            (await _orderRepository.Create(_activeOrder with { Id = null })).Id;
        
        Assert.Equal(firstAutogeneratedId.Length, secondAutogeneratedId.Length);
        Assert.NotEqual(firstAutogeneratedId, secondAutogeneratedId);
    }

    [Fact]
    public async Task OlderOrdersAreNotIncludedByGreaterThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Create(
            _activeOrder with { Created = oldestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateGreaterThan(newestDate);
        
        Assert.DoesNotContain(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task NewerOrdersAreNotExcludedByGreaterThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Create(
            _activeOrder with { Created = newestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateGreaterThan(oldestDate);
        
        Assert.Contains(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task OlderOrdersAreNotExcludedByLessThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Create(
            _activeOrder with { Created = oldestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateLessThan(newestDate);
        
        Assert.Contains(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task NewerOrdersAreNotIncludedByLessThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Create(
            _activeOrder with { Created = newestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateLessThan(oldestDate);
        
        Assert.DoesNotContain(expectedOrder, actualOrders);
    }

    [Fact]
    public async Task OrdersWithinRangeAreNotExcludedByDateBetweenFilter()
    {
        var (oldestDate, currentDate, newestDate) = _getDateTriple();
        var expectedOrder = await _orderRepository.Create(
            _activeOrder with { Created = currentDate });

        var actualOrders = await _orderRepository.FindActiveWithCreatedDateBetweenDates(
            oldestDate: oldestDate, newestDate: newestDate);

        Assert.Contains(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task OrdersOutsideRangeAreNotIncludedByDateBetweenFilter()
    {
        var (oldestDate, currentDate, newestDate) = _getDateTriple();
        var expectedOrder = await _orderRepository.Create(
            _activeOrder with { Created = newestDate });

        var actualOrders = await _orderRepository.FindActiveWithCreatedDateBetweenDates(
            oldestDate: oldestDate, newestDate: currentDate);

        Assert.DoesNotContain(expectedOrder, actualOrders);
    }
}

public partial class InMemoryOrderRepositoryTests
{
    private Order _activeOrder => new()
    {
        Id = "01HAP11BKZN3XKZCVA1TJZTT4T",
        Status = OrderStatus.Active,
        Created = new DateTimeOffset(new DateTime(2023, 01, 01)),
        OrderProducts = new List<OrderProduct>
        {
            new() { ProductId = "01HAP05RW9A0V5Z8NZ57A73JMY", Quantity = 1 }
        }
    };
    private Order _cancelledOrder => new()
    {
        Id = "01HAP11MBTH9ZNF9X21RMAY70C",
        Status = OrderStatus.Cancelled,
        Created = new DateTimeOffset(new DateTime(2023, 01, 01)),
        OrderProducts = new List<OrderProduct>
        {
            new() { ProductId = "01HAP05RW9A0V5Z8NZ57A73JMY", Quantity = 1 }
        }
    };
    
    private InMemoryOrderRepository _orderRepository { get; set; }

    public InMemoryOrderRepositoryTests()
    {
        var db = new ApplicationContext();
        db.Database.EnsureDeleted();
        _orderRepository = new InMemoryOrderRepository(db);
    }

    private DatePair _getDatePair()
    {
        var current = DateTimeOffset.Now;
        return new DatePair(Oldest: current, Newest: current.AddSeconds(1));
    }
    
    private DateTriple _getDateTriple()
    {
        var current = DateTimeOffset.Now;
        return new DateTriple(current.AddSeconds(-1), current, current.AddSeconds(1));
    }
}

internal record DatePair(DateTimeOffset Oldest, DateTimeOffset Newest)
{
    public DateTimeOffset Oldest { get; set; } = Oldest;
    public DateTimeOffset Newest { get; set; } = Newest;

    public void Deconstruct(out DateTimeOffset oldest, out DateTimeOffset newest) =>
        (oldest, newest) = (Oldest, Newest);
}

internal record DateTriple(
    DateTimeOffset Oldest, DateTimeOffset Current, DateTimeOffset Newest)
{
    public DateTimeOffset Oldest { get; set; } = Oldest;
    public DateTimeOffset Current { get; set; } = Current;
    public DateTimeOffset Newest { get; set; } = Newest;

    public void Deconstruct(
        out DateTimeOffset oldest, out DateTimeOffset current, out DateTimeOffset newest)
    {
        oldest = Oldest;
        current = Current;
        newest = Newest;
    }
}