using TixTrack.WebApiInterview.Entities;
using TixTrack.WebApiInterview.Repositories;
using TixTrack.WebApiInterview.Repositories.Context;
using Xunit;

namespace TixTrack.WebApiInterview.IntegrationTests.Repositories;

public partial class InMemoryOrderRepositoryTests
{
    [Fact]
    public async Task ActiveOrdersDoNotContainCancelledOrders()
    {
        var expectedOrders = new List<Order> { _activeOrder, _cancelledOrder };
        await Task.WhenAll(expectedOrders.Select(_orderRepository.Insert));

        var actualActiveOrders = await _orderRepository.FindActive();

        Assert.Single(actualActiveOrders);
        Assert.Equal(expectedOrders.First(), actualActiveOrders.Single());
    }

    [Fact]
    public async Task AllOrdersContainActiveAndCancelledOrders()
    {
        var expectedOrders = new List<Order> { _activeOrder, _cancelledOrder };
        await Task.WhenAll(expectedOrders.Select(_orderRepository.Insert));
        
        var actualOrders = await _orderRepository.FindAll();

        Assert.All(expectedOrders,
            expectedOrder => Assert.Contains(expectedOrder, actualOrders));
    }
    
    [Fact]
    public async Task OrderIdIsAutogeneratedByRepository()
    {
        var firstAutogeneratedId =
            (await _orderRepository.Insert(_activeOrder with { Id = null })).Id;
        var secondAutogeneratedId =
            (await _orderRepository.Insert(_activeOrder with { Id = null })).Id;
        
        Assert.Equal(firstAutogeneratedId?.Length, secondAutogeneratedId?.Length);
        Assert.NotEqual(firstAutogeneratedId, secondAutogeneratedId);
    }

    [Fact]
    public async Task OlderOrdersAreNotIncludedByGreaterThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Insert(
            _activeOrder with { Created = oldestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateGreaterThan(newestDate);
        
        Assert.DoesNotContain(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task NewerOrdersAreNotExcludedByGreaterThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Insert(
            _activeOrder with { Created = newestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateGreaterThan(oldestDate);
        
        Assert.Contains(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task OlderOrdersAreNotExcludedByLessThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Insert(
            _activeOrder with { Created = oldestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateLessThan(newestDate);
        
        Assert.Contains(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task NewerOrdersAreNotIncludedByLessThanFilter()
    {
        var (oldestDate, newestDate) = _getDatePair();
        var expectedOrder = await _orderRepository.Insert(
            _activeOrder with { Created = newestDate });

        var actualOrders =
            await _orderRepository.FindActiveWithCreatedDateLessThan(oldestDate);
        
        Assert.DoesNotContain(expectedOrder, actualOrders);
    }

    [Fact]
    public async Task OrdersWithinRangeAreNotExcludedByDateBetweenFilter()
    {
        var (oldestDate, currentDate, newestDate) = _getDateTriple();
        var expectedOrder = await _orderRepository.Insert(
            _activeOrder with { Created = currentDate });

        var actualOrders = await _orderRepository.FindActiveWithCreatedDateBetweenDates(
            oldestDate: oldestDate, newestDate: newestDate);

        Assert.Contains(expectedOrder, actualOrders);
    }
    
    [Fact]
    public async Task OrdersOutsideRangeAreNotIncludedByDateBetweenFilter()
    {
        var (oldestDate, currentDate, newestDate) = _getDateTriple();
        var expectedOrder = await _orderRepository.Insert(
            _activeOrder with { Created = newestDate });

        var actualOrders = await _orderRepository.FindActiveWithCreatedDateBetweenDates(
            oldestDate: oldestDate, newestDate: currentDate);

        Assert.DoesNotContain(expectedOrder, actualOrders);
    }

    [Fact]
    public async Task TopOrdersDoesNotExceedCount()
    {
        var orders = new[] { 10, 11, 12 }.Select(_getNewActiveOrder).ToList();
        await Task.WhenAll(orders.Select(_orderRepository.Insert));

        var actualOrders = await _orderRepository.FindTopOrderProductsByQuantity(count: 2);

        var expectedOrderCount = 2;
        Assert.Equal(expectedOrderCount, actualOrders.Count);
    }
    
    [Fact]
    public async Task OrdersAreNotSortedByLowestProductQuantities()
    {
        var allQuantities = new[] { 11, 12, 13, 10 };
        await Task.WhenAll(allQuantities.Select(_createOrderByProductQuantity));
        var expectedQuantities = allQuantities.Skip(1).Take(2).ToList();

        var actualQuantities =
            (await _orderRepository.FindTopOrderProductsByQuantity(count: 2))
            .Select(orderProduct => orderProduct.Quantity)
            .ToList();

        Assert.Equal(expectedQuantities.Count, actualQuantities.Count);
        Assert.Contains(expectedQuantities, actualQuantities.Contains);
    }
}

public partial class InMemoryOrderRepositoryTests
{
    private Order _activeOrder => _getOrder(
        id: "01HAP11BKZN3XKZCVA1TJZTT4T",
        status: OrderStatus.Active,
        productQuantity: 1);

    private Order _cancelledOrder => _getOrder(
            id: "01HAP11MBTH9ZNF9X21RMAY70C",
            status: OrderStatus.Cancelled,
            productQuantity: 1);

    private InMemoryOrderRepository _orderRepository { get; set; }

    public InMemoryOrderRepositoryTests()
    {
        var db = new ApplicationContext();
        db.Database.EnsureDeleted();
        _orderRepository = new InMemoryOrderRepository(db);
    }
    
    private Task _createOrderByProductQuantity(int productQuantity) =>
        _orderRepository.Insert(_getNewActiveOrder(productQuantity));

    private Order _getNewActiveOrder(int productQuantity) =>
        _getOrder(_getNewOrderId(), OrderStatus.Active, productQuantity);

    private string _getNewOrderId() => Ulid.NewUlid().ToString();
    
    private Order _getOrder(string id, OrderStatus status, int productQuantity)
    {
        return new Order
        {
            Id = id,
            Status = status,
            Created = new DateTimeOffset(new DateTime(2023, 01, 01)),
            OrderProducts = new List<OrderProduct>
            {
                new()
                {
                    ProductId = "01HAP05RW9A0V5Z8NZ57A73JMY",
                    Quantity = productQuantity
                }
            }
        };
    }

    private DatePair _getDatePair()
    {
        var current = DateTimeOffset.Now;
        return new DatePair(Oldest: current, Newest: current.AddSeconds(1));
    }
    
    private DateTriple _getDateTriple()
    {
        var current = DateTimeOffset.Now;
        return new DateTriple(current.AddSeconds(-1), current, current.AddSeconds(1));
    }
}

internal record DatePair(DateTimeOffset Oldest, DateTimeOffset Newest)
{
    public DateTimeOffset Oldest { get; set; } = Oldest;
    public DateTimeOffset Newest { get; set; } = Newest;

    public void Deconstruct(out DateTimeOffset oldest, out DateTimeOffset newest) =>
        (oldest, newest) = (Oldest, Newest);
}

internal record DateTriple(
    DateTimeOffset Oldest, DateTimeOffset Current, DateTimeOffset Newest)
{
    public DateTimeOffset Oldest { get; set; } = Oldest;
    public DateTimeOffset Current { get; set; } = Current;
    public DateTimeOffset Newest { get; set; } = Newest;

    public void Deconstruct(
        out DateTimeOffset oldest, out DateTimeOffset current, out DateTimeOffset newest)
    {
        oldest = Oldest;
        current = Current;
        newest = Newest;
    }
}